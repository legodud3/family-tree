<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Family Relationship Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 40px 40px 48px;
      background: #f4f5f7;
      color: #111827;
    }

    .container {
      background: #ffffff;
      padding: 40px 56px 40px;
      border-radius: 24px;
      box-shadow: 0 22px 60px rgba(15, 23, 42, 0.10);
      max-width: 1100px;
      width: 100%;
    }

    .question-row {
      font-size: 1.5rem;
      line-height: 1.7;
      text-align: center;
      margin-bottom: 24px;
    }

    select {
      font-size: 1rem;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      max-width: 320px;
    }

    select:focus {
      outline: none;
      border-color: #4f46e5;
      box-shadow: 0 0 0 1px #4f46e5;
    }

    .answer {
      margin-top: 32px;
      padding-top: 20px;
      border-top: 1px solid #e5e7eb;
      min-height: 32px;
    }

    .answer-label {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #6b7280;
      margin-bottom: 4px;
    }

    .answer-path {
      font-size: 1.1rem;
      font-weight: 500;
      color: #111827;
      word-break: break-word;
    }

    .hint {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #9ca3af;
      text-align: center;
    }

    .muted {
      color: #9ca3af;
      font-style: italic;
    }

    .grid {
      margin-top: 32px;
      position: relative;
      width: 100%;
      min-height: 180px;
    }

    .grid-node {
      position: absolute;
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #ffffff;
      white-space: nowrap;
      font-size: 0.95rem;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.10);
    }

    .grid-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: visible;
      pointer-events: none;
    }

    @media (max-width: 768px) {
      body {
        align-items: flex-start;
        padding: 20px 12px 24px;
      }

      .container {
        max-width: 100%;
        padding: 28px 16px 24px;
        border-radius: 0;
        box-shadow: none;
      }

      .question-row {
        font-size: 1.25rem;
        line-height: 1.5;
      }

      select {
        width: 100%;
        max-width: 100%;
        margin-top: 8px;
      }

      .answer-path {
        font-size: 1.05rem;
      }

      .grid-node {
        font-size: 0.9rem;
        padding: 6px 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="question-row">
      How is
      <select id="target-select">
        <option value="">select a person</option>
      </select>
      related to me?
    </div>
    <div class="answer" id="answer">
      <div class="answer-label">Relationship path</div>
      <div class="answer-path muted">Pick someone to see how they connect to you.</div>
      <div id="grid" class="grid"></div>
    </div>
  </div>

  <script>
    // Fixed "me" id for v0 (Chinmay)
    const ME_ID = 1;

    // v0 data: 7 people
    // 1: Chinmay Deo (me)
    // 2: Sanjita Israni (wife)
    // 3: Kedar Deo (father)
    // 4: Nishigandha Deo (mother)
    // 5: Jitendra Israni (father-in-law)
    // 6: Taruna Israni (mother-in-law)
    // 7: Jigglypuff (child)

    const data = {
      people: [
        { id: 1, name: "Chinmay Deo" },
        { id: 2, name: "Sanjita Israni" },
        { id: 3, name: "Kedar Deo" },
        { id: 4, name: "Nishigandha Deo" },
        { id: 5, name: "Jitendra Israni" },
        { id: 6, name: "Taruna Israni" },
        { id: 7, name: "Jigglypuff" }
      ],
      relationships: [
        // Parents of Chinmay
        { from_id: 3, to_id: 1, type: "parent" }, // Kedar -> Chinmay
        { from_id: 4, to_id: 1, type: "parent" }, // Nishigandha -> Chinmay

        // Parents of Sanjita
        { from_id: 5, to_id: 2, type: "parent" }, // Jitendra -> Sanjita
        { from_id: 6, to_id: 2, type: "parent" }, // Taruna -> Sanjita

        // Spouses
        { from_id: 1, to_id: 2, type: "spouse" }, // Chinmay & Sanjita
        { from_id: 3, to_id: 4, type: "spouse" }, // Kedar & Nishigandha
        { from_id: 5, to_id: 6, type: "spouse" }, // Jitendra & Taruna

        // Parents of Jigglypuff
        { from_id: 1, to_id: 7, type: "parent" }, // Chinmay -> Jigglypuff
        { from_id: 2, to_id: 7, type: "parent" }  // Sanjita -> Jigglypuff
      ]
    };

    function buildAdjacencyList(relationships) {
      const adj = new Map();

      function addEdge(a, b) {
        if (!adj.has(a)) adj.set(a, []);
        adj.get(a).push(b);
      }

      for (const rel of relationships) {
        const { from_id, to_id } = rel;
        // Undirected graph for pathfinding: add both directions
        addEdge(from_id, to_id);
        addEdge(to_id, from_id);
      }

      return adj;
    }

    function bfsPath(startId, targetId, adj) {
      if (startId === targetId) {
        return [startId];
      }

      const queue = [startId];
      const visited = new Set([startId]);
      const parent = new Map(); // childId -> parentId

      while (queue.length > 0) {
        const current = queue.shift();
        const neighbours = adj.get(current) || [];

        for (const next of neighbours) {
          if (!visited.has(next)) {
            visited.add(next);
            parent.set(next, current);
            if (next === targetId) {
              // Reconstruct path
              const path = [targetId];
              let cur = targetId;
              while (parent.has(cur)) {
                cur = parent.get(cur);
                path.push(cur);
              }
              return path.reverse();
            }
            queue.push(next);
          }
        }
      }

      // No path found
      return null;
    }

    function getPersonById(id) {
      return data.people.find(p => p.id === id) || null;
    }

    function getRelationshipLabel(aId, bId) {
      const rel = data.relationships.find(
        r =>
          (r.from_id === aId && r.to_id === bId) ||
          (r.from_id === bId && r.to_id === aId)
      );
      if (!rel) return "";
      if (rel.type === "spouse") return "spouse of";
      if (rel.type === "sibling") return "sibling of";
      if (rel.type === "parent") {
        // Directional: from_id is parent of to_id
        return rel.from_id === aId ? "parent of" : "child of";
      }
      return "";
    }

    function getGenerationDelta(aId, bId) {
      const rel = data.relationships.find(
        r =>
          (r.from_id === aId && r.to_id === bId) ||
          (r.from_id === bId && r.to_id === aId)
      );
      if (!rel) return 0;
      if (rel.type === "spouse" || rel.type === "sibling") return 0;
      if (rel.type === "parent") {
        // Directional: from_id is parent of to_id
        if (rel.from_id === aId && rel.to_id === bId) {
          // moving parent -> child: go down a generation
          return -1;
        }
        if (rel.from_id === bId && rel.to_id === aId) {
          // moving child -> parent: go up a generation
          return 1;
        }
      }
      return 0;
    }

    function renderGrid(pathIds) {
      const grid = document.getElementById("grid");
      if (!grid) return;

      // Clear previous diagram
      grid.innerHTML = "";

      if (!pathIds || pathIds.length === 0) {
        return;
      }

      // Compute levels (generation) and column positions along the path.
      // level: 0 for "You", +1 for parents, -1 for children, etc.
      // col: stays the same for vertical moves (parent/child), moves right for same-generation moves.
      const indexed = [];
      let currentLevel = 0;
      let currentCol = 1;
      indexed.push({ id: pathIds[0], level: currentLevel, col: currentCol });

      for (let i = 0; i < pathIds.length - 1; i++) {
        const aId = pathIds[i];
        const bId = pathIds[i + 1];
        const delta = getGenerationDelta(aId, bId);
        currentLevel += delta;

        if (delta === 0) {
          // spouse / sibling: same generation, move to the right
          currentCol += 1;
        } else {
          // parent / child: stay in the same column, move up/down a generation
          // (already handled by currentLevel)
        }

        indexed.push({ id: bId, level: currentLevel, col: currentCol });
      }

      // Determine min/max levels for row mapping
      let minLevel = 0;
      let maxLevel = 0;
      for (const entry of indexed) {
        if (entry.level < minLevel) minLevel = entry.level;
        if (entry.level > maxLevel) maxLevel = entry.level;
      }

      const rowsCount = maxLevel - minLevel + 1;
      const colsCount = Math.max(...indexed.map(e => e.col));

      // Map logical level to row index (0-based), with highest level at the top
      const levelToRow = new Map();
      for (let level = minLevel; level <= maxLevel; level++) {
        const rowIndex = maxLevel - level; // 0-based
        levelToRow.set(level, rowIndex);
      }

      // Layout: spread columns evenly across the available width,
      // and stack rows with generous vertical rhythm.
      const CELL_Y = 110;
      const PADDING_Y = 40;

      const containerWidth = grid.clientWidth || 600;
      const cols = Math.max(colsCount, 1);
      const horizontalStep = containerWidth / (cols + 1);

      const height = rowsCount * CELL_Y + PADDING_Y * 2;
      grid.style.height = `${height}px`;

      // Compute positions
      const posById = new Map();
      for (const entry of indexed) {
        const rowIndex = levelToRow.get(entry.level);
        const colIndex = entry.col; // 1-based
        const x = horizontalStep * colIndex;
        const y = PADDING_Y + rowIndex * CELL_Y;
        posById.set(entry.id, { x, y });
      }

      // Create SVG overlay
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", containerWidth);
      svg.setAttribute("height", height);
      svg.classList.add("grid-svg");
      grid.appendChild(svg);

      // Draw edges with labels
      for (let i = 0; i < pathIds.length - 1; i++) {
        const aId = pathIds[i];
        const bId = pathIds[i + 1];
        const posA = posById.get(aId);
        const posB = posById.get(bId);
        if (!posA || !posB) continue;

        const label = getRelationshipLabel(aId, bId) || "";

        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", posA.x);
        line.setAttribute("y1", posA.y);
        line.setAttribute("x2", posB.x);
        line.setAttribute("y2", posB.y);
        line.setAttribute("stroke", "#d1d5db");
        line.setAttribute("stroke-width", "1.4");
        line.setAttribute("stroke-linecap", "round");
        svg.appendChild(line);

        if (label) {
          const text = document.createElementNS(svgNS, "text");
          let mx = (posA.x + posB.x) / 2;
          let my = (posA.y + posB.y) / 2;

          // Offset label depending on orientation
          if (Math.abs(posA.y - posB.y) < 4) {
            // Horizontal-ish
            my -= 12;
          } else {
            // Vertical-ish
            mx += 44;
          }

          text.setAttribute("x", mx);
          text.setAttribute("y", my);
          text.setAttribute("fill", "#6b7280");
          text.setAttribute("font-size", "11");
          text.setAttribute("letter-spacing", "0.02em");
          text.setAttribute("text-anchor", "middle");
          text.textContent = label;
          svg.appendChild(text);
        }
      }

      // Draw nodes on top
      for (const entry of indexed) {
        const pos = posById.get(entry.id);
        if (!pos) continue;

        const person = getPersonById(entry.id);
        const nodeEl = document.createElement("div");
        nodeEl.className = "grid-node";
        nodeEl.textContent =
          entry.id === ME_ID
            ? "You"
            : (person ? person.name : `Unknown(${entry.id})`);
        nodeEl.style.left = `${pos.x}px`;
        nodeEl.style.top = `${pos.y}px`;
        nodeEl.style.transform = "translate(-50%, -50%)";
        grid.appendChild(nodeEl);
      }
    }

    function renderPath(pathIds) {
      const answerEl = document.getElementById("answer");
      const labelEl = answerEl.querySelector(".answer-label");
      const pathEl = answerEl.querySelector(".answer-path");

      if (!pathIds || pathIds.length === 0) {
        labelEl.textContent = "Relationship path";
        pathEl.textContent = "No path found.";
        pathEl.classList.remove("muted");
        renderGrid(null);
        return;
      }

      labelEl.textContent = "Relationship path";

      if (pathIds.length === 1) {
        pathEl.textContent = "You";
        pathEl.classList.remove("muted");
        renderGrid(pathIds);
        return;
      }

      let result = "";
      for (let i = 0; i < pathIds.length - 1; i++) {
        const aId = pathIds[i];
        const bId = pathIds[i + 1];
        const aName =
          i === 0 ? "You" : (getPersonById(aId)?.name || `Unknown(${aId})`);
        const bName = getPersonById(bId)?.name || `Unknown(${bId})`;
        const label = getRelationshipLabel(aId, bId) || "?";

        if (i === 0) {
          result += aName + " ";
        }
        result += `-(${label})-> ${bName}`;
        if (i < pathIds.length - 2) {
          result += " ";
        }
      }

      pathEl.textContent = result;
      pathEl.classList.remove("muted");
      renderGrid(pathIds);
    }

    function onTargetChange(event) {
      const value = event.target.value;
      const answerEl = document.getElementById("answer");
      const pathEl = answerEl.querySelector(".answer-path");

      if (!value) {
        pathEl.textContent = "Pick someone to see how they connect to you.";
        pathEl.classList.add("muted");
        return;
      }

      const targetId = Number(value);
      const adj = buildAdjacencyList(data.relationships);
      const path = bfsPath(ME_ID, targetId, adj);

      if (!path) {
        renderPath(null);
      } else {
        renderPath(path);
      }
    }

    function init() {
      const select = document.getElementById("target-select");

      // Populate the dropdown with all people except ME_ID
      const others = data.people.filter(p => p.id !== ME_ID);
      for (const person of others) {
        const opt = document.createElement("option");
        opt.value = String(person.id);
        opt.textContent = person.name;
        select.appendChild(opt);
      }

      select.addEventListener("change", onTargetChange);
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
