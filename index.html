<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Family Relationship Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f4f5f7;
      color: #111827;
    }

    .container {
      background: #ffffff;
      padding: 32px 28px 28px;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
      max-width: 720px;
      width: 100%;
    }

    .question-row {
      font-size: 1.25rem;
      line-height: 1.6;
      text-align: center;
    }

    select {
      font-size: 1rem;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      max-width: 260px;
    }

    select:focus {
      outline: none;
      border-color: #4f46e5;
      box-shadow: 0 0 0 1px #4f46e5;
    }

    .answer {
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid #e5e7eb;
      min-height: 24px;
    }

    .answer-label {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #6b7280;
      margin-bottom: 4px;
    }

    .answer-path {
      font-size: 1.05rem;
      font-weight: 500;
      color: #111827;
      word-break: break-word;
    }

    .hint {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #9ca3af;
      text-align: center;
    }

    .muted {
      color: #9ca3af;
      font-style: italic;
    }

    .grid {
      margin-top: 12px;
      display: grid;
      justify-content: center;
      row-gap: 4px;
      column-gap: 8px;
    }

    .grid-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      min-height: 24px;
      font-size: 0.9rem;
    }

    .grid-node {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      white-space: nowrap;
    }

    .grid-edge-vertical,
    .grid-edge-horizontal {
      position: relative;
      font-size: 0.7rem;
      color: #6b7280;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .grid-edge-vertical::before {
      content: "";
      position: absolute;
      left: 50%;
      top: 2px;
      bottom: 2px;
      border-left: 1px solid #d1d5db;
      transform: translateX(-50%);
      z-index: -1;
    }

    .grid-edge-horizontal::before {
      content: "";
      position: absolute;
      left: 4px;
      right: 4px;
      top: 50%;
      border-top: 1px solid #d1d5db;
      transform: translateY(-50%);
      z-index: -1;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="question-row">
      How is
      <select id="target-select">
        <option value="">select a person</option>
      </select>
      related to me?
    </div>
    <div class="answer" id="answer">
      <div class="answer-label">Relationship path</div>
      <div class="answer-path muted">Pick someone to see how they connect to you.</div>
      <div id="grid" class="grid"></div>
    </div>
  </div>

  <script>
    // Fixed "me" id for v0 (Chinmay)
    const ME_ID = 1;

    // v0 data: 7 people
    // 1: Chinmay Deo (me)
    // 2: Sanjita Israni (wife)
    // 3: Kedar Deo (father)
    // 4: Nishigandha Deo (mother)
    // 5: Jitendra Israni (father-in-law)
    // 6: Taruna Israni (mother-in-law)
    // 7: Jigglypuff (child)

    const data = {
      people: [
        { id: 1, name: "Chinmay Deo" },
        { id: 2, name: "Sanjita Israni" },
        { id: 3, name: "Kedar Deo" },
        { id: 4, name: "Nishigandha Deo" },
        { id: 5, name: "Jitendra Israni" },
        { id: 6, name: "Taruna Israni" },
        { id: 7, name: "Jigglypuff" }
      ],
      relationships: [
        // Parents of Chinmay
        { from_id: 3, to_id: 1, type: "parent" }, // Kedar -> Chinmay
        { from_id: 4, to_id: 1, type: "parent" }, // Nishigandha -> Chinmay

        // Parents of Sanjita
        { from_id: 5, to_id: 2, type: "parent" }, // Jitendra -> Sanjita
        { from_id: 6, to_id: 2, type: "parent" }, // Taruna -> Sanjita

        // Spouses
        { from_id: 1, to_id: 2, type: "spouse" }, // Chinmay & Sanjita
        { from_id: 3, to_id: 4, type: "spouse" }, // Kedar & Nishigandha
        { from_id: 5, to_id: 6, type: "spouse" }, // Jitendra & Taruna

        // Parents of Jigglypuff
        { from_id: 1, to_id: 7, type: "parent" }, // Chinmay -> Jigglypuff
        { from_id: 2, to_id: 7, type: "parent" }  // Sanjita -> Jigglypuff
      ]
    };

    function buildAdjacencyList(relationships) {
      const adj = new Map();

      function addEdge(a, b) {
        if (!adj.has(a)) adj.set(a, []);
        adj.get(a).push(b);
      }

      for (const rel of relationships) {
        const { from_id, to_id } = rel;
        // Undirected graph for pathfinding: add both directions
        addEdge(from_id, to_id);
        addEdge(to_id, from_id);
      }

      return adj;
    }

    function bfsPath(startId, targetId, adj) {
      if (startId === targetId) {
        return [startId];
      }

      const queue = [startId];
      const visited = new Set([startId]);
      const parent = new Map(); // childId -> parentId

      while (queue.length > 0) {
        const current = queue.shift();
        const neighbours = adj.get(current) || [];

        for (const next of neighbours) {
          if (!visited.has(next)) {
            visited.add(next);
            parent.set(next, current);
            if (next === targetId) {
              // Reconstruct path
              const path = [targetId];
              let cur = targetId;
              while (parent.has(cur)) {
                cur = parent.get(cur);
                path.push(cur);
              }
              return path.reverse();
            }
            queue.push(next);
          }
        }
      }

      // No path found
      return null;
    }

    function getPersonById(id) {
      return data.people.find(p => p.id === id) || null;
    }

    function getRelationshipLabel(aId, bId) {
      const rel = data.relationships.find(
        r =>
          (r.from_id === aId && r.to_id === bId) ||
          (r.from_id === bId && r.to_id === aId)
      );
      if (!rel) return "";
      if (rel.type === "spouse") return "spouse of";
      if (rel.type === "sibling") return "sibling of";
      if (rel.type === "parent") {
        // Directional: from_id is parent of to_id
        return rel.from_id === aId ? "parent of" : "child of";
      }
      return "";
    }

    function getGenerationDelta(aId, bId) {
      const rel = data.relationships.find(
        r =>
          (r.from_id === aId && r.to_id === bId) ||
          (r.from_id === bId && r.to_id === aId)
      );
      if (!rel) return 0;
      if (rel.type === "spouse" || rel.type === "sibling") return 0;
      if (rel.type === "parent") {
        // Directional: from_id is parent of to_id
        if (rel.from_id === aId && rel.to_id === bId) {
          // moving parent -> child: go down a generation
          return -1;
        }
        if (rel.from_id === bId && rel.to_id === aId) {
          // moving child -> parent: go up a generation
          return 1;
        }
      }
      return 0;
    }

    function renderGrid(pathIds) {
      const grid = document.getElementById("grid");
      if (!grid) return;

      // Clear previous grid
      grid.innerHTML = "";

      if (!pathIds || pathIds.length === 0) {
        return;
      }

      // Compute levels (generation) and column positions along the path.
      // level: 0 for "You", +1 for parents, -1 for children, etc.
      // col: stays the same for vertical moves (parent/child), moves right for same-generation moves.
      const indexed = [];
      let currentLevel = 0;
      let currentCol = 1;
      indexed.push({ id: pathIds[0], level: currentLevel, col: currentCol });

      for (let i = 0; i < pathIds.length - 1; i++) {
        const aId = pathIds[i];
        const bId = pathIds[i + 1];
        const delta = getGenerationDelta(aId, bId);
        currentLevel += delta;

        if (delta === 0) {
          // spouse / sibling: same generation, move to the right
          currentCol += 1;
        } else {
          // parent / child: stay in the same column, move up/down a generation
          // (already handled by currentLevel)
        }

        indexed.push({ id: bId, level: currentLevel, col: currentCol });
      }

      // Determine min/max levels for row mapping
      let minLevel = 0;
      let maxLevel = 0;
      for (const entry of indexed) {
        if (entry.level < minLevel) minLevel = entry.level;
        if (entry.level > maxLevel) maxLevel = entry.level;
      }

      const rowsCount = maxLevel - minLevel + 1;
      const colsCount = Math.max(...indexed.map(e => e.col));

      // Map logical level to grid row index (1-based), with highest level at the top
      const levelToRow = new Map();
      for (let level = minLevel; level <= maxLevel; level++) {
        const rowIndex = maxLevel - level + 1;
        levelToRow.set(level, rowIndex);
      }

      // Configure CSS grid template
      grid.style.gridTemplateRows = `repeat(${rowsCount}, auto)`;
      grid.style.gridTemplateColumns = `repeat(${colsCount}, minmax(0, auto))`;

      // Build a lookup for positions by id
      const posById = new Map();

      // Add node elements
      for (const entry of indexed) {
        const row = levelToRow.get(entry.level);
        const col = entry.col;
        posById.set(entry.id, { row, col });

        const person = getPersonById(entry.id);
        const nodeEl = document.createElement("div");
        nodeEl.className = "grid-node";
        nodeEl.textContent =
          entry.id === ME_ID
            ? "You"
            : (person ? person.name : `Unknown(${entry.id})`);
        nodeEl.style.gridRow = String(row);
        nodeEl.style.gridColumn = String(col);
        grid.appendChild(nodeEl);
      }

      // Add edge elements with labels ("child of", "spouse of", etc.)
      for (let i = 0; i < pathIds.length - 1; i++) {
        const aId = pathIds[i];
        const bId = pathIds[i + 1];
        const posA = posById.get(aId);
        const posB = posById.get(bId);
        if (!posA || !posB) continue;

        const label = getRelationshipLabel(aId, bId) || "";

        if (posA.row === posB.row) {
          // Horizontal edge (same generation)
          const edgeEl = document.createElement("div");
          edgeEl.className = "grid-edge-horizontal";
          const minCol = Math.min(posA.col, posB.col);
          const maxCol = Math.max(posA.col, posB.col);
          edgeEl.style.gridRow = String(posA.row);
          edgeEl.style.gridColumn = `${minCol} / ${maxCol + 1}`;
          edgeEl.textContent = label;
          grid.appendChild(edgeEl);
        } else {
          // Vertical edge (parent/child)
          const edgeEl = document.createElement("div");
          edgeEl.className = "grid-edge-vertical";
          const minRow = Math.min(posA.row, posB.row);
          const maxRow = Math.max(posA.row, posB.row);
          // Use the child's column for the line, which is also the parent column by construction
          const col = posB.col;
          edgeEl.style.gridColumn = String(col);
          edgeEl.style.gridRow = `${minRow} / ${maxRow + 1}`;
          edgeEl.textContent = label;
          grid.appendChild(edgeEl);
        }
      }
    }

    function renderPath(pathIds) {
      const answerEl = document.getElementById("answer");
      const labelEl = answerEl.querySelector(".answer-label");
      const pathEl = answerEl.querySelector(".answer-path");

      if (!pathIds || pathIds.length === 0) {
        labelEl.textContent = "Relationship path";
        pathEl.textContent = "No path found.";
        pathEl.classList.remove("muted");
        renderGrid(null);
        return;
      }

      labelEl.textContent = "Relationship path";

      if (pathIds.length === 1) {
        pathEl.textContent = "You";
        pathEl.classList.remove("muted");
        renderGrid(pathIds);
        return;
      }

      let result = "";
      for (let i = 0; i < pathIds.length - 1; i++) {
        const aId = pathIds[i];
        const bId = pathIds[i + 1];
        const aName =
          i === 0 ? "You" : (getPersonById(aId)?.name || `Unknown(${aId})`);
        const bName = getPersonById(bId)?.name || `Unknown(${bId})`;
        const label = getRelationshipLabel(aId, bId) || "?";

        if (i === 0) {
          result += aName + " ";
        }
        result += `-(${label})-> ${bName}`;
        if (i < pathIds.length - 2) {
          result += " ";
        }
      }

      pathEl.textContent = result;
      pathEl.classList.remove("muted");
      renderGrid(pathIds);
    }

    function onTargetChange(event) {
      const value = event.target.value;
      const answerEl = document.getElementById("answer");
      const pathEl = answerEl.querySelector(".answer-path");

      if (!value) {
        pathEl.textContent = "Pick someone to see how they connect to you.";
        pathEl.classList.add("muted");
        return;
      }

      const targetId = Number(value);
      const adj = buildAdjacencyList(data.relationships);
      const path = bfsPath(ME_ID, targetId, adj);

      if (!path) {
        renderPath(null);
      } else {
        renderPath(path);
      }
    }

    function init() {
      const select = document.getElementById("target-select");

      // Populate the dropdown with all people except ME_ID
      const others = data.people.filter(p => p.id !== ME_ID);
      for (const person of others) {
        const opt = document.createElement("option");
        opt.value = String(person.id);
        opt.textContent = person.name;
        select.appendChild(opt);
      }

      select.addEventListener("change", onTargetChange);
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
